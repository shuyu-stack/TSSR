# Astuces PowerShell pour l'Exploitation

> **Module :** Emploi Technicien Exploitation
> **Date :** Janvier 2026
> **Niveau :** N0-N1
> **Prérequis :** Bases PowerShell

---

## Pourquoi ce fichier ?

En exploitation, tu vas devoir faire des **vérifications rapides** sur des serveurs distants. Voici les commandes que tu vas utiliser **tous les jours**.

> **Conseil de ton mentor :** Garde ce fichier ouvert. Copie-colle les commandes. Ne réinvente pas la roue.

---

## Active Directory - Gestion des comptes

### Vérifier un compte utilisateur

```powershell
# Rechercher un utilisateur par son login
Get-ADUser -Identity "jdupont" -Properties *

# Version courte avec les infos essentielles
Get-ADUser -Identity "jdupont" -Properties LockedOut, Enabled, PasswordExpired, PasswordLastSet, LastLogonDate |
    Select-Object Name, SamAccountName, Enabled, LockedOut, PasswordExpired, PasswordLastSet, LastLogonDate
```

**Résultat attendu :**
```
Name            : Jean DUPONT
SamAccountName  : jdupont
Enabled         : True
LockedOut       : False
PasswordExpired : False
PasswordLastSet : 10/01/2026 09:15:23
LastLogonDate   : 14/01/2026 08:30:45
```

### Rechercher un utilisateur (si tu n'as pas le login exact)

```powershell
# Par nom (partiel)
Get-ADUser -Filter "Name -like '*dupont*'" | Select-Object SamAccountName, Name, Enabled

# Par email
Get-ADUser -Filter "EmailAddress -eq 'jean.dupont@entreprise.fr'" -Properties EmailAddress

# Par service (si renseigné dans AD)
Get-ADUser -Filter "Department -eq 'Comptabilité'" -Properties Department |
    Select-Object SamAccountName, Name, Department
```

### Débloquer un compte verrouillé

```powershell
# Débloquer
Unlock-ADAccount -Identity "jdupont"

# Vérifier que c'est débloqué
(Get-ADUser -Identity "jdupont" -Properties LockedOut).LockedOut
# Doit retourner : False

# Script complet avec confirmation
$user = "jdupont"
Unlock-ADAccount -Identity $user
$status = (Get-ADUser -Identity $user -Properties LockedOut).LockedOut
if ($status -eq $false) {
    Write-Host "Compte $user débloqué avec succès" -ForegroundColor Green
} else {
    Write-Host "ERREUR : Le compte est toujours verrouillé" -ForegroundColor Red
}
```

### Réinitialiser un mot de passe

```powershell
# Réinitialiser avec mot de passe temporaire
Set-ADAccountPassword -Identity "jdupont" -Reset -NewPassword (ConvertTo-SecureString "TempPass123!" -AsPlainText -Force)

# Forcer le changement au prochain login
Set-ADUser -Identity "jdupont" -ChangePasswordAtLogon $true

# Script complet
$user = "jdupont"
$tempPassword = "Welcome2026!"

Set-ADAccountPassword -Identity $user -Reset -NewPassword (ConvertTo-SecureString $tempPassword -AsPlainText -Force)
Set-ADUser -Identity $user -ChangePasswordAtLogon $true

Write-Host "Mot de passe de $user réinitialisé. Temporaire : $tempPassword" -ForegroundColor Yellow
Write-Host "L'utilisateur devra le changer à la prochaine connexion." -ForegroundColor Yellow
```

### Vérifier les groupes d'un utilisateur

```powershell
# Lister tous les groupes
Get-ADPrincipalGroupMembership -Identity "jdupont" |
    Select-Object Name |
    Sort-Object Name

# Vérifier si l'utilisateur est dans un groupe spécifique
$user = "jdupont"
$groupe = "GRP_VPN_Users"

if ((Get-ADPrincipalGroupMembership -Identity $user).Name -contains $groupe) {
    Write-Host "$user est membre de $groupe" -ForegroundColor Green
} else {
    Write-Host "$user n'est PAS membre de $groupe" -ForegroundColor Red
}
```

### Trouver les comptes verrouillés

```powershell
# Tous les comptes verrouillés du domaine
Search-ADAccount -LockedOut | Select-Object Name, SamAccountName, LockedOut

# Comptes verrouillés dans une OU spécifique
Search-ADAccount -LockedOut -SearchBase "OU=Users,DC=entreprise,DC=local" |
    Select-Object Name, SamAccountName
```

---

## Diagnostic serveur distant

### Vérifier si un serveur répond

```powershell
# Ping simple
Test-Connection -ComputerName "SRV-WEB-01" -Count 2

# Version rapide (True/False)
Test-Connection -ComputerName "SRV-WEB-01" -Count 1 -Quiet

# Tester plusieurs serveurs
$serveurs = @("SRV-WEB-01", "SRV-DB-01", "SRV-APP-01")
$serveurs | ForEach-Object {
    $result = Test-Connection -ComputerName $_ -Count 1 -Quiet
    if ($result) {
        Write-Host "$_ : OK" -ForegroundColor Green
    } else {
        Write-Host "$_ : DOWN" -ForegroundColor Red
    }
}
```

### Tester un port spécifique

```powershell
# Test port 443 (HTTPS)
Test-NetConnection -ComputerName "SRV-WEB-01" -Port 443

# Test port 3389 (RDP)
Test-NetConnection -ComputerName "SRV-WEB-01" -Port 3389

# Test port 1433 (SQL Server)
Test-NetConnection -ComputerName "SRV-DB-01" -Port 1433

# Version courte
(Test-NetConnection -ComputerName "SRV-WEB-01" -Port 443).TcpTestSucceeded
```

### Vérifier l'espace disque

```powershell
# Sur un serveur distant
Get-WmiObject -ComputerName "SRV-WEB-01" -Class Win32_LogicalDisk |
    Where-Object { $_.DriveType -eq 3 } |
    Select-Object DeviceID,
        @{n='Taille_GB';e={[math]::Round($_.Size/1GB,2)}},
        @{n='Libre_GB';e={[math]::Round($_.FreeSpace/1GB,2)}},
        @{n='Pourcent_Libre';e={[math]::Round($_.FreeSpace/$_.Size*100,2)}}

# Alerter si disque < 10% libre
$seuil = 10
Get-WmiObject -ComputerName "SRV-WEB-01" -Class Win32_LogicalDisk |
    Where-Object { $_.DriveType -eq 3 } |
    ForEach-Object {
        $pctLibre = [math]::Round($_.FreeSpace/$_.Size*100,2)
        $disk = $_.DeviceID
        if ($pctLibre -lt $seuil) {
            Write-Host "ALERTE : $disk a seulement $pctLibre% libre !" -ForegroundColor Red
        } else {
            Write-Host "$disk : $pctLibre% libre" -ForegroundColor Green
        }
    }
```

### Vérifier CPU et mémoire

```powershell
# CPU actuel
Get-WmiObject -ComputerName "SRV-WEB-01" -Class Win32_Processor |
    Select-Object @{n='CPU_Pourcent';e={$_.LoadPercentage}}

# Mémoire
Get-WmiObject -ComputerName "SRV-WEB-01" -Class Win32_OperatingSystem |
    Select-Object @{n='RAM_Total_GB';e={[math]::Round($_.TotalVisibleMemorySize/1MB,2)}},
                  @{n='RAM_Libre_GB';e={[math]::Round($_.FreePhysicalMemory/1MB,2)}},
                  @{n='RAM_Utilisee_Pourcent';e={[math]::Round((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)/$_.TotalVisibleMemorySize)*100,2)}}
```

### Vérifier l'uptime (depuis quand le serveur tourne)

```powershell
# Uptime d'un serveur
$os = Get-WmiObject -ComputerName "SRV-WEB-01" -Class Win32_OperatingSystem
$uptime = (Get-Date) - $os.ConvertToDateTime($os.LastBootUpTime)
Write-Host "Uptime : $($uptime.Days) jours, $($uptime.Hours) heures, $($uptime.Minutes) minutes"
```

---

## Gestion des services

### Vérifier l'état d'un service

```powershell
# Un service spécifique
Get-Service -ComputerName "SRV-WEB-01" -Name "W3SVC" | Select-Object Name, Status, DisplayName

# Plusieurs services
Get-Service -ComputerName "SRV-WEB-01" -Name "W3SVC","WAS","MSSQLSERVER" -ErrorAction SilentlyContinue |
    Select-Object Name, Status, DisplayName

# Tous les services arrêtés (qui devraient tourner)
Get-Service -ComputerName "SRV-WEB-01" |
    Where-Object { $_.StartType -eq 'Automatic' -and $_.Status -ne 'Running' } |
    Select-Object Name, Status, DisplayName
```

### Redémarrer un service

```powershell
# Redémarrer un service
Get-Service -ComputerName "SRV-WEB-01" -Name "W3SVC" | Restart-Service

# Avec vérification
$service = "W3SVC"
$serveur = "SRV-WEB-01"

Write-Host "Redémarrage de $service sur $serveur..." -ForegroundColor Yellow
Get-Service -ComputerName $serveur -Name $service | Restart-Service

Start-Sleep -Seconds 5

$status = (Get-Service -ComputerName $serveur -Name $service).Status
if ($status -eq 'Running') {
    Write-Host "$service redémarré avec succès" -ForegroundColor Green
} else {
    Write-Host "ERREUR : $service est en état $status" -ForegroundColor Red
}
```

### Démarrer/Arrêter un service

```powershell
# Démarrer
Get-Service -ComputerName "SRV-WEB-01" -Name "W3SVC" | Start-Service

# Arrêter
Get-Service -ComputerName "SRV-WEB-01" -Name "W3SVC" | Stop-Service
```

---

## Consultation des logs

### Dernières erreurs dans les logs

```powershell
# Erreurs dans Application log (dernières 24h)
Get-EventLog -ComputerName "SRV-WEB-01" -LogName Application -EntryType Error -After (Get-Date).AddHours(-24) |
    Select-Object TimeGenerated, Source, Message -First 20

# Erreurs dans System log
Get-EventLog -ComputerName "SRV-WEB-01" -LogName System -EntryType Error -After (Get-Date).AddHours(-24) |
    Select-Object TimeGenerated, Source, Message -First 20
```

### Chercher un événement spécifique

```powershell
# Chercher par mot-clé dans le message
Get-EventLog -ComputerName "SRV-WEB-01" -LogName Application -Newest 100 |
    Where-Object { $_.Message -like "*SQL*" } |
    Select-Object TimeGenerated, Source, Message

# Chercher par Event ID
Get-EventLog -ComputerName "SRV-WEB-01" -LogName System |
    Where-Object { $_.EventID -eq 7036 } | # 7036 = Service started/stopped
    Select-Object TimeGenerated, Message -First 10
```

### Événements de sécurité (connexions)

```powershell
# Dernières connexions réussies (Event ID 4624)
Get-WinEvent -ComputerName "SRV-WEB-01" -FilterHashtable @{
    LogName='Security'
    ID=4624
} -MaxEvents 20 | Select-Object TimeCreated, Message

# Connexions échouées (Event ID 4625)
Get-WinEvent -ComputerName "SRV-WEB-01" -FilterHashtable @{
    LogName='Security'
    ID=4625
} -MaxEvents 20 | Select-Object TimeCreated, Message
```

---

## Script de diagnostic complet

```powershell
function Get-ServerDiagnostic {
    <#
    .SYNOPSIS
    Diagnostic rapide d'un serveur distant
    .EXAMPLE
    Get-ServerDiagnostic -ComputerName "SRV-WEB-01"
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$ComputerName
    )

    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host " DIAGNOSTIC : $ComputerName" -ForegroundColor Cyan
    Write-Host "========================================`n" -ForegroundColor Cyan

    # Test connectivité
    Write-Host "[1/6] Test de connectivité..." -ForegroundColor Yellow
    $ping = Test-Connection -ComputerName $ComputerName -Count 1 -Quiet
    if ($ping) {
        Write-Host "    Ping : OK" -ForegroundColor Green
    } else {
        Write-Host "    Ping : ECHEC - Serveur injoignable" -ForegroundColor Red
        return
    }

    # Uptime
    Write-Host "`n[2/6] Uptime..." -ForegroundColor Yellow
    try {
        $os = Get-WmiObject -ComputerName $ComputerName -Class Win32_OperatingSystem -ErrorAction Stop
        $uptime = (Get-Date) - $os.ConvertToDateTime($os.LastBootUpTime)
        Write-Host "    Uptime : $($uptime.Days)j $($uptime.Hours)h $($uptime.Minutes)m" -ForegroundColor Green
    } catch {
        Write-Host "    Erreur : Impossible de récupérer l'uptime" -ForegroundColor Red
    }

    # CPU
    Write-Host "`n[3/6] CPU..." -ForegroundColor Yellow
    try {
        $cpu = Get-WmiObject -ComputerName $ComputerName -Class Win32_Processor -ErrorAction Stop
        $cpuLoad = $cpu.LoadPercentage
        if ($cpuLoad -gt 90) {
            Write-Host "    CPU : $cpuLoad% - CRITIQUE" -ForegroundColor Red
        } elseif ($cpuLoad -gt 70) {
            Write-Host "    CPU : $cpuLoad% - ATTENTION" -ForegroundColor Yellow
        } else {
            Write-Host "    CPU : $cpuLoad% - OK" -ForegroundColor Green
        }
    } catch {
        Write-Host "    Erreur : Impossible de récupérer le CPU" -ForegroundColor Red
    }

    # Mémoire
    Write-Host "`n[4/6] Mémoire..." -ForegroundColor Yellow
    try {
        $mem = Get-WmiObject -ComputerName $ComputerName -Class Win32_OperatingSystem -ErrorAction Stop
        $memUsed = [math]::Round((($mem.TotalVisibleMemorySize - $mem.FreePhysicalMemory)/$mem.TotalVisibleMemorySize)*100,2)
        $memFreeGB = [math]::Round($mem.FreePhysicalMemory/1MB,2)
        if ($memUsed -gt 90) {
            Write-Host "    RAM : $memUsed% utilisée ($memFreeGB GB libre) - CRITIQUE" -ForegroundColor Red
        } elseif ($memUsed -gt 80) {
            Write-Host "    RAM : $memUsed% utilisée ($memFreeGB GB libre) - ATTENTION" -ForegroundColor Yellow
        } else {
            Write-Host "    RAM : $memUsed% utilisée ($memFreeGB GB libre) - OK" -ForegroundColor Green
        }
    } catch {
        Write-Host "    Erreur : Impossible de récupérer la mémoire" -ForegroundColor Red
    }

    # Disques
    Write-Host "`n[5/6] Disques..." -ForegroundColor Yellow
    try {
        $disks = Get-WmiObject -ComputerName $ComputerName -Class Win32_LogicalDisk -ErrorAction Stop |
            Where-Object { $_.DriveType -eq 3 }
        foreach ($disk in $disks) {
            $pctFree = [math]::Round($disk.FreeSpace/$disk.Size*100,2)
            $freeGB = [math]::Round($disk.FreeSpace/1GB,2)
            if ($pctFree -lt 10) {
                Write-Host "    $($disk.DeviceID) : $pctFree% libre ($freeGB GB) - CRITIQUE" -ForegroundColor Red
            } elseif ($pctFree -lt 20) {
                Write-Host "    $($disk.DeviceID) : $pctFree% libre ($freeGB GB) - ATTENTION" -ForegroundColor Yellow
            } else {
                Write-Host "    $($disk.DeviceID) : $pctFree% libre ($freeGB GB) - OK" -ForegroundColor Green
            }
        }
    } catch {
        Write-Host "    Erreur : Impossible de récupérer les disques" -ForegroundColor Red
    }

    # Dernières erreurs
    Write-Host "`n[6/6] Dernières erreurs (24h)..." -ForegroundColor Yellow
    try {
        $errors = Get-EventLog -ComputerName $ComputerName -LogName Application -EntryType Error -After (Get-Date).AddHours(-24) -ErrorAction Stop
        if ($errors.Count -gt 0) {
            Write-Host "    $($errors.Count) erreurs trouvées" -ForegroundColor Yellow
            $errors | Select-Object TimeGenerated, Source -First 5 | ForEach-Object {
                Write-Host "    - $($_.TimeGenerated) : $($_.Source)" -ForegroundColor Gray
            }
        } else {
            Write-Host "    Aucune erreur dans les dernières 24h" -ForegroundColor Green
        }
    } catch {
        Write-Host "    Erreur : Impossible de lire les logs" -ForegroundColor Red
    }

    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host " FIN DU DIAGNOSTIC" -ForegroundColor Cyan
    Write-Host "========================================`n" -ForegroundColor Cyan
}

# Utilisation :
# Get-ServerDiagnostic -ComputerName "SRV-WEB-01"
```

---

## Commandes réseau

### Résolution DNS

```powershell
# Résoudre un nom
Resolve-DnsName -Name "intranet.entreprise.local"

# Vérifier un enregistrement spécifique
Resolve-DnsName -Name "intranet.entreprise.local" -Type A
Resolve-DnsName -Name "mail.entreprise.local" -Type MX

# Vider le cache DNS local
Clear-DnsClientCache
```

### Traceroute

```powershell
# Tracer la route vers un serveur
Test-NetConnection -ComputerName "SRV-WEB-01" -TraceRoute
```

### Vérifier les ports ouverts localement

```powershell
# Ports en écoute
Get-NetTCPConnection -State Listen |
    Select-Object LocalPort, OwningProcess |
    Sort-Object LocalPort

# Avec le nom du processus
Get-NetTCPConnection -State Listen |
    Select-Object LocalPort, @{n='Process';e={(Get-Process -Id $_.OwningProcess).ProcessName}} |
    Sort-Object LocalPort
```

---

## Bonnes pratiques

### Toujours tester avant d'agir

```powershell
# Utiliser -WhatIf pour simuler
Stop-Service -Name "W3SVC" -WhatIf

# Utiliser -Confirm pour demander confirmation
Restart-Service -Name "W3SVC" -Confirm
```

### Logger tes actions

```powershell
# Démarrer la transcription
Start-Transcript -Path "C:\Logs\intervention_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"

# ... tes commandes ...

# Arrêter la transcription
Stop-Transcript
```

### Stocker les serveurs fréquents

```powershell
# Créer un fichier de serveurs
$serveurs = @{
    "WEB" = "SRV-WEB-01"
    "DB"  = "SRV-DB-01"
    "APP" = "SRV-APP-01"
    "AD"  = "SRV-DC-01"
}

# Utiliser
Test-Connection -ComputerName $serveurs.WEB -Count 1 -Quiet
Get-Service -ComputerName $serveurs.DB -Name "MSSQLSERVER"
```

---

## Checklist de révision

- [ ] Je sais vérifier et débloquer un compte AD
- [ ] Je sais réinitialiser un mot de passe
- [ ] Je sais vérifier l'état d'un serveur (ping, CPU, RAM, disque)
- [ ] Je sais vérifier et redémarrer un service
- [ ] Je sais consulter les logs d'événements
- [ ] Je sais tester la connectivité réseau (ping, port, DNS)

---

<div align="center">

[Retour au sommaire](./README.md)

</div>
